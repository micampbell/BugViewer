@using System.Numerics
@using System.Drawing
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@inject IJSRuntime JS
@implements IAsyncDisposable

<div class="page-container" style="width:@Width; height:@Height;">

    @* WebGPU canvas fills the viewport *@

    <canvas id="webgpu-canvas"
            class="webgpu-canvas"
            style="height:100%; width:100%;"
            tabindex="0"
            Options="_currentOptions"
            @ref="_canvasRef"
            @onpointerdown="OnPointerDown"
            @onpointermove="OnPointerMove"
            @onpointerup="OnPointerUp"
            @onwheel="OnWheel"
            @onwheel:preventDefault="true"
            @onkeydown="OnKeyDown"
            @onkeyup="OnKeyUp"
            @oncontextmenu:preventDefault="true">
    </canvas>

    @* Settings panel overlays in top-right corner *@
    <OptionsPanel Options="Options" @bind-IsExpanded="_isOptionsPanelExpanded" />

    @* Camera control buttons panel - below options panel *@
    <div class="camera-controls-panel">
        <button class="camera-btn reset-btn" @onclick="HandleCameraReset" title="Reset Camera">
            🔄
        </button>
        <button class="camera-btn" @onclick="@(() => HandleCameraCardinalView(CardinalDirection.NegativeX))" title="View from -X">
            -X
        </button>
        <button class="camera-btn" @onclick="@(() => HandleCameraCardinalView(CardinalDirection.PositiveX))" title="View from +X">
            +X
        </button>
        <button class="camera-btn" @onclick="@(() => HandleCameraCardinalView(CardinalDirection.NegativeY))" title="View from -Y">
            -Y
        </button>
        <button class="camera-btn" @onclick="@(() => HandleCameraCardinalView(CardinalDirection.PositiveY))" title="View from +Y">
            +Y
        </button>
        <button class="camera-btn" @onclick="@(() => HandleCameraCardinalView(CardinalDirection.NegativeZ))" title="View from -Z">
            -Z
        </button>
        <button class="camera-btn" @onclick="@(() => HandleCameraCardinalView(CardinalDirection.PositiveZ))" title="View from +Z">
            +Z
        </button>
    </div>

    @* Control instructions panel - shows when ? key is held *@
    @if (_showControls)
    {
        <div class="controls-panel">
            <h4>🎮 Camera Controls</h4>
            <div class="control-group">
                <strong>🖱️ Mouse:</strong>
                <ul>
                    <li><strong>Left Drag:</strong> Rotate camera</li>
                    <li><strong>Right Drag:</strong> Pan view</li>
                    <li><strong>Scroll Wheel:</strong> Zoom in/out</li>
                    <li><strong>Double-Click:</strong> Pick/select objects</li>
                </ul>
            </div>
            <div class="control-group">
                <strong>⌨️ Keyboard:</strong>
                <ul>
                    <li><strong>W/S:</strong> Move forward/backward</li>
                    <li><strong>A/D:</strong> Move left/right</li>
                    <li><strong>Q/E:</strong> Move down/up</li>
                    <li><strong>Shift:</strong> Hold for faster movement</li>
                </ul>
            </div>
            <div class="hint">Press <strong>?</strong> to toggle this help</div>
        </div>
    }

    @* Help hint indicator *@
    @if (!_showControls)
    {
        <div class="help-hint">
            Press <strong>?</strong> for controls
        </div>
    }

</div>

<style>
    .page-container {
        position: relative;
        /* Removed width: 100%; - now uses inline style parameter */
        overflow: hidden;
    }

        .page-container:focus {
            outline: none;
        }

    body {
        margin: 0;
        padding: 0;
    }

    .controls-panel {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: rgba(30, 30, 30, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 16px 20px;
        color: white;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        font-size: 13px;
        z-index: 1000;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
        max-width: 280px;
        backdrop-filter: blur(10px);
        animation: slideIn 0.2s ease-out;
    }

    @@keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .controls-panel h4 {
        margin: 0 0 12px 0;
        font-size: 16px;
        font-weight: 600;
        color: #4fc3f7;
    }

    .control-group {
        margin-bottom: 12px;
    }

        .control-group:last-child {
            margin-bottom: 12px;
        }

        .control-group strong {
            color: #ffa726;
            font-size: 14px;
        }

    .controls-panel ul {
        margin: 6px 0 0 0;
        padding-left: 20px;
        list-style: none;
    }

    .controls-panel li {
        margin: 4px 0;
        line-height: 1.4;
    }

        .controls-panel li strong {
            color: #81c784;
            font-weight: 600;
        }

        .controls-panel li::before {
            content: '▸';
            color: #4fc3f7;
            margin-right: 6px;
        }

    .controls-panel .hint {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        font-size: 12px;
        color: rgba(255, 255, 255, 0.6);
        text-align: center;
    }

        .controls-panel .hint strong {
            color: #4fc3f7;
            font-weight: 600;
        }

    .help-hint {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: rgba(30, 30, 30, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 8px 12px;
        color: rgba(255, 255, 255, 0.7);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        font-size: 12px;
        z-index: 1000;
        backdrop-filter: blur(5px);
        animation: pulse 2s ease-in-out infinite;
    }

        .help-hint strong {
            color: #4fc3f7;
            font-weight: 600;
        }

    @@keyframes pulse {
        0%, 100% {
            opacity: 0.6;
        }

        50% {
            opacity: 1;
        }
    }

    /* Camera control buttons panel */
    .camera-controls-panel {
        position: absolute;
        top: 70px;
        right: 10px;
        background: rgba(30, 30, 30, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
        z-index: 999;
        padding: 8px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 6px;
        min-width: 200px;
    }

    .camera-btn {
        background: rgba(79, 195, 247, 0.15);
        border: 1px solid rgba(79, 195, 247, 0.3);
        border-radius: 6px;
        color: #4fc3f7;
        font-size: 12px;
        font-weight: 600;
        padding: 8px 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        white-space: nowrap;
    }

        .camera-btn:hover {
            background: rgba(79, 195, 247, 0.25);
            border-color: rgba(79, 195, 247, 0.5);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(79, 195, 247, 0.3);
        }

        .camera-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(79, 195, 247, 0.2);
        }

        .camera-btn.reset-btn {
            background: rgba(255, 167, 38, 0.15);
            border-color: rgba(255, 167, 38, 0.3);
            color: #ffa726;
            font-size: 16px;
        }

            .camera-btn.reset-btn:hover {
                background: rgba(255, 167, 38, 0.25);
                border-color: rgba(255, 167, 38, 0.5);
                box-shadow: 0 2px 8px rgba(255, 167, 38, 0.3);
            }

    @@media (max-width: 500px) {
        .camera-controls-panel {
            grid-template-columns: repeat(3, 1fr);
            min-width: 150px;
        }
    }
</style>

@code {

    [Parameter]
    public string Width { get; set; } = "100%";

    [Parameter]
    public string Height { get; set; } = "100vh";

    private ElementReference? _canvasRef;
    private bool _showControls = false;
    private bool _isOptionsPanelExpanded = false;


    private BugViewerOptions _options;

    /// <summary>
    /// WebGPU rendering options. Pass a configured instance to control grid appearance and camera.
    /// </summary>
    [Parameter]
    public BugViewerOptions Options
    {
        get => _options;
        set
        {
            if (!ReferenceEquals(_options, value))
            {
                _options = value;
                _options.PropertyChanged += OnOptionsChanged;
            }
        }
    }

    /// <summary>
    /// Camera instance for controlling the 3D view.
    /// </summary>
    public OrbitCamera? Camera { get; private set; }

    /// <summary>
    /// Event raised when a picking ray is created (e.g., on double-click).
    /// Subscribers can use this ray to perform triangle/primitive intersection tests.
    /// </summary>
    public event Action<Ray>? OnPickingRayCreated;

    private IJSObjectReference? _module;
    private DotNetObjectReference<BugViewer>? _dotNetRef;
    private bool _ready;
    private string? _error;
    private bool _isDragging;
    private bool _isPanning;
    private double _lastPointerX;
    private double _lastPointerY;
    private HashSet<string> _pressedKeys = new();
    private System.Threading.Timer? _keyboardMoveTimer;
    private Sphere totalSphere;
    private Dictionary<AbstractObject3D, Sphere> objectSpheres = new();
    private List<MeshData> _meshes = new();
    private List<LineData> _lines = new();
    private List<MeshData> _billBoards = new();
    // Canvas dimensions for projection matrix computation
    private double _canvasWidth = 800;
    private double _canvasHeight = 600;

    // Double-click detection
    private DateTime _lastClickTime = DateTime.MinValue;
    private double _lastClickX;
    private double _lastClickY;
    private const double DoubleClickTimeMs = 300; // Standard double-click time window
    private const double DoubleClickDistancePx = 5; // Maximum distance for double-click

    public double LatestFrameMs { get; private set; }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
    }

    protected override void OnInitialized()
    {
        if (Options is null)
            Options = BugViewerOptions.Default;
        Camera = new OrbitCamera(Vector3.Zero, Options);
        // Start keyboard movement timer (60 FPS for smooth movement)
        _keyboardMoveTimer = new System.Threading.Timer(_ => ProcessKeyboardMovement(), null, 0, 16);

        // No direct subscription here; handled in Options setter above.
    }

    #region Public Facing Methods
    /// <summary>
    /// Adds a mesh to the WebGPU scene for rendering.
    /// </summary>
    public async Task AddMeshAsync(MeshData mesh)
    {
        _meshes.Add(mesh);
        UpdateViewer(UpdateSpheresAdd(mesh));
        await _module.InvokeVoidAsync("addMesh", mesh.CreateJavascriptData());
    }

    /// <summary>
    /// Adds lines to the WebGPU scene for rendering.
    /// </summary>
    public async Task AddLinesAsync(LineData path)
    {
        _lines.Add(path);
        UpdateViewer(UpdateSpheresAdd(path));
        await _module.InvokeVoidAsync("addLines", path.CreateJavascriptData());
    }

    /// <summary>
    /// Removes a mesh from the scene by its ID.
    /// </summary>
    public async Task RemoveMeshAsync(MeshData mesh)
    {
        var index = _meshes.IndexOf(mesh);
        if (index < 0) return;
        UpdateViewer(UpdateSpheresRemove(mesh));
        await _module.InvokeVoidAsync("removeMesh", index);
    }
    private async void UpdateViewer(bool sphereChanged)
    {
        if ((sphereChanged && _options.AutoResetCamera == UpdateTypes.SphereChange)
        || _options.AutoResetCamera == UpdateTypes.OnDataChange)
        {
            ResetCamera();
            await _module!.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
        }
        if ((sphereChanged && _options.AutoUpdateGrid == UpdateTypes.SphereChange)
        || _options.AutoUpdateGrid == UpdateTypes.OnDataChange)
        {
            _options.GridSize = _options.AutoGridBuffer * (totalSphere.Center.Length() + totalSphere.GetRadius());
            OnOptionsChanged(null, null);
        }
    }
    /// <summary>
    /// Removes lines from the scene by their ID.
    /// </summary>
    public async Task RemoveLinesAsync(LineData path)
    {
        var index = _lines.IndexOf(path);
        if (index < 0) return;
        UpdateViewer(UpdateSpheresRemove(path));
        await _module.InvokeVoidAsync("removeLines", index);
    }

    /// <summary>
    /// Clears all dynamically added meshes from the scene.
    /// </summary>
    public async Task ClearAllMeshesAsync()
    {
        if (_meshes.Count == 0) return;
        var needToUpdate = _meshes.All(m => UpdateSpheresRemove(m));
        _meshes.Clear();
        UpdateViewer(needToUpdate);
        await _module.InvokeVoidAsync("clearAllMeshes");
    }

    /// <summary>
    /// Clears all dynamically added lines from the scene.
    /// </summary>
    public async Task ClearAllLinesAsync()
    {
        if (_lines.Count == 0) return;
        var needToUpdate = _lines.All(m => UpdateSpheresRemove(m));
        _lines.Clear();
        UpdateViewer(needToUpdate);
        await _module.InvokeVoidAsync("clearAllLines");
    }

    /// <summary>
    /// Adds a text billboard to the WebGPU scene for rendering.
    /// </summary>
    public async Task AddTextBillboardAsync(string id, string text, Vector3 position, Color backgroundColor, Color textColor)
    {
        if (_module is null || !_ready)
        {
            throw new InvalidOperationException("WebGPU is not ready. Wait for initialization.");
        }

        // Render text to bitmap in C# instead of JavaScript
        var billboardData = new TextBillboard
        {
            BackgroundColor = backgroundColor,
            TextColor = textColor,
            Text = text,
            Vertices = new List<Vector3> { position },
            Id = id
        };
        await _module.InvokeVoidAsync("addTextBillboard", billboardData.CreateJavascriptData());
    }

    /// <summary>
    /// Removes a text billboard from the scene by its ID.
    /// </summary>
    public async Task RemoveTextBillboardAsync(string id)
    {
        if (_module is null) return;
        await _module.InvokeVoidAsync("removeTextBillboard", id);
    }

    /// <summary>
    /// Clears all text billboards from the scene.
    /// </summary>
    public async Task ClearAllTextBillboardsAsync()
    {
        if (_module is null) return;
        await _module.InvokeVoidAsync("clearAllTextBillboards");
    }
    #endregion
    #region Tasks and Events
    private void OnPointerDown(PointerEventArgs e)
    {
        var currentTime = DateTime.Now;
        var timeSinceLastClick = (currentTime - _lastClickTime).TotalMilliseconds;
        var distanceFromLastClick = Math.Sqrt(
            Math.Pow(e.ClientX - _lastClickX, 2) +
            Math.Pow(e.ClientY - _lastClickY, 2));

        // Check for double-click (left mouse button only)
        if (e.Button == 0 &&
            timeSinceLastClick <= DoubleClickTimeMs &&
            distanceFromLastClick <= DoubleClickDistancePx)
        {
            // Double-click detected - handle it here
            OnDoubleClick(e);
            return; // Don't process as single click
        }

        // Update last click info for next potential double-click
        if (e.Button == 0)
        {
            _lastClickTime = currentTime;
            _lastClickX = e.ClientX;
            _lastClickY = e.ClientY;
        }

        if (e.Button == 0) // Left mouse button - rotate
        {
            _isDragging = true;
            _isPanning = false;
            _lastPointerX = e.ClientX;
            _lastPointerY = e.ClientY;
        }
        else if (e.Button == 2) // Middle mouse button - pan
        {
            _isPanning = true;
            _isDragging = false;
            _lastPointerX = e.ClientX;
            _lastPointerY = e.ClientY;
        }
    }

    private async Task OnDoubleClick(PointerEventArgs e)
    {
        if (_module is null || !_ready)
        {
            return; // WebGPU not ready
        }

        // Get canvas dimensions using JavaScript interop
        var canvasRect = await _module.InvokeAsync<BoundingClientRect>("getBoundingClientRect", _canvasRef);
        var canvasWidth = canvasRect.Width;
        var canvasHeight = canvasRect.Height;

        // Convert mouse Center relative to canvas
        var relativeX = e.ClientX - canvasRect.Left;
        var relativeY = e.ClientY - canvasRect.Top;

        // Create picking ray from camera through mouse Center
        var pickingRay = Camera.CreateRayFromScreenPoint(relativeX, relativeY, canvasWidth, canvasHeight);

        await AddTextBillboardAsync("myBillboard", "Hello World", pickingRay.Anchor + 15 * pickingRay.Direction, System.Drawing.Color.Blue,
        System.Drawing.Color.White);
        // Raise event for subscribers to handle picking
        OnPickingRayCreated?.Invoke(pickingRay);
    }

    // Helper class for bounding client rect
    private class BoundingClientRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    private async Task OnPointerMove(PointerEventArgs e)
    {
        if (_isDragging)
        {
            var deltaX = e.ClientX - _lastPointerX;
            var deltaY = e.ClientY - _lastPointerY;

            _lastPointerX = e.ClientX;
            _lastPointerY = e.ClientY;

            // Update camera orbit
            Camera.Orbit(deltaX, deltaY);

            // Send updated view matrix to JavaScript
            if (_module != null && _ready)
            {
                await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
            }
        }
        else if (_isPanning)
        {
            var deltaX = e.ClientX - _lastPointerX;
            var deltaY = e.ClientY - _lastPointerY;

            _lastPointerX = e.ClientX;
            _lastPointerY = e.ClientY;

            // Update camera pan (Shift key check)
            Camera.PanWithMouse(deltaX, deltaY, e.ShiftKey);

            // Send updated view matrix to JavaScript
            if (_module != null && _ready)
            {
                await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
            }
        }
    }

    private void OnPointerUp(PointerEventArgs e)
    {
        if (e.Button == 0)
        {
            _isDragging = false;
        }
        else if (e.Button == 2)
        {
            _isPanning = false;
        }
    }

    private async Task OnWheel(WheelEventArgs e)
    {
        // Update camera zoom
        Camera.Zoom(e.DeltaY);

        // Send updated view matrix to JavaScript
        if (_module != null && _ready)
        {
            await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
        }
    }

    private void OnKeyDown(KeyboardEventArgs e)
    {
        // Show controls when ? key is pressed (Shift + / or direct ?)
        if (e.Key == "?" || (e.Key == "/" && e.ShiftKey))
        {
            _showControls = true;
            StateHasChanged();
        }
        else
            // Track pressed keys (allow multiple simultaneous keys)
            _pressedKeys.Add(e.Key.ToLower());
    }

    private void OnKeyUp(KeyboardEventArgs e)
    {
        // Hide controls when ? key is released
        if (e.Key == "?" || e.Key == "/")
        {
            _showControls = false;
            StateHasChanged();
        }
        else
            // Remove key from pressed set
            _pressedKeys.Remove(e.Key.ToLower());
    }

    private async void ProcessKeyboardMovement()
    {
        if (_pressedKeys.Count == 0 || _module == null || !_ready) return;

        // Calculate movement direction from pressed keys
        double forward = 0, right = 0, up = 0;
        bool shiftPressed = _pressedKeys.Contains("shift");

        // WASD for horizontal/forward movement
        if (_pressedKeys.Contains("w")) forward += 1;
        if (_pressedKeys.Contains("s")) forward -= 1;
        if (_pressedKeys.Contains("d")) right += 1;
        if (_pressedKeys.Contains("a")) right -= 1;

        // Q/E for vertical movement
        if (_pressedKeys.Contains("q")) up -= 1;
        if (_pressedKeys.Contains("e")) up += 1;

        // Apply movement if any key is pressed
        if (forward != 0 || right != 0 || up != 0)
        {
            Camera.PanWithKeyboard(forward, right, up, shiftPressed);

            // Send updated view matrix to JavaScript
            try
            {
                await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
            }
            catch
            {
                // Ignore exceptions during rapid updates
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        // Subscribe to picking events
        OnPickingRayCreated += OnPickingRayRun;
        // One-time initialization: import module and create .NET reference
        try
        {
            // Add version parameter to force cache refresh
            _module = await JS.InvokeAsync<IJSObjectReference>("import", $"/_content/BugViewer/js/webgpu-canvas.js?v={DateTime.UtcNow.Ticks}");
        }
        catch (JSException jse)
        {
            _module = null;
            _error = $"Failed to import webgpu module: {jse.Message}";
            Console.Error.WriteLine(_error);
            try { await JS.InvokeVoidAsync("console.error", _error); } catch { }
            StateHasChanged();
            return;
        }
        catch (Exception ex)
        {
            _module = null;
            _error = $"Unexpected error importing webgpu module: {ex.Message}";
            Console.Error.WriteLine(_error);
            try { await JS.InvokeVoidAsync("console.error", _error); } catch { }
            StateHasChanged();
            return;
        }

        // Create DotNetObjectReference for JS -> .NET callbacks
        _dotNetRef = DotNetObjectReference.Create(this);

        // Send initial options and view matrix (this triggers the render loop in JS)
        try
        {
            await SendOptionsToJavaScriptAsync(isInitializing: true);
        }
        catch (Exception ex)
        {
            _error = $"Error initializing WebGPU canvas: {ex.Message}";
            Console.Error.WriteLine(_error);
            try { await JS.InvokeVoidAsync("console.error", _error); } catch { }
            StateHasChanged();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Only send updates after the module is loaded (after first render)
        await SendOptionsToJavaScriptAsync(isInitializing: false);
    }

    private async Task SendOptionsToJavaScriptAsync(bool isInitializing)
    {
        // Guard: module must be loaded (happens after first render)
        if (_module is null) return;

        if (isInitializing)
        {
            // Pass normalized options on first init to avoid shape mismatches
            await _module.InvokeVoidAsync(
                "initGPU_Canvas",
                _dotNetRef,
                _canvasRef,
                Options.ToJavascriptOptions(),
                Camera.ConvertMatrixToJavaScript());
        }
        else
        {
            // Hot-update with the same normalized shape
            await _module.InvokeVoidAsync("updateDisplayOptions", Options.ToJavascriptOptions());

            // Recompute and send projection matrix when options change
            // (in case projection-related options like FOV, ortho size, etc. changed)
            await SendProjectionMatrixToJavaScriptAsync();
        }
    }

    [JSInvokable]
    public Task OnFrameMsUpdate(double ms)
    {
        LatestFrameMs = ms;
        // No StateHasChanged to avoid re-render per frame; consumer can bind to events if desired
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnWebGpuReady()
    {
        _ready = true;
        _error = null;

        // Send initial projection matrix after WebGPU is ready
        await SendProjectionMatrixToJavaScriptAsync();

        StateHasChanged();
    }

    [JSInvokable]
    public Task OnWebGpuError(string message)
    {
        _ready = false;
        _error = message;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnCanvasResized(double width, double height)
    {
        _canvasWidth = width;
        _canvasHeight = height;

        // Recompute and send projection matrix when canvas size changes
        await SendProjectionMatrixToJavaScriptAsync();
    }

    private async Task SendProjectionMatrixToJavaScriptAsync()
    {
        if (_module is null || !_ready || Camera is null) return;

        try
        {
            var projectionMatrix = Camera.ConvertProjectionMatrixToJavaScript(_canvasWidth, _canvasHeight);
            await _module.InvokeVoidAsync("writeProjectionMatrix", projectionMatrix);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error sending projection matrix: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        Camera = new OrbitCamera(Camera.Target, Options);
        // Stop keyboard timer
        _keyboardMoveTimer?.Dispose();

        Options.PropertyChanged -= OnOptionsChanged;

        if (_module is not null)
        {
            try { await _module.InvokeVoidAsync("disposeWebGPU_Canvas"); } catch { /* ignore */ }
            try { await _module.DisposeAsync(); } catch { /* ignore */ }
        }

        _dotNetRef?.Dispose();
    }

    public void ResetCamera()
    {
        // Reset camera to default Center and orientation
        Camera.Reset(totalSphere);

        // Send updated view matrix to JavaScript
        _module?.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
    }

    private async Task HandleCameraReset() => ResetCamera();

    private async Task HandleCameraCardinalView(CardinalDirection direction)
    {
        if (Camera is null) return;
        ResetCamera();
        Camera.SetCardinalView(direction);

        // Send updated view matrix to JavaScript
        if (_module != null && _ready)
        {
            await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
        }
    }
    #endregion
    private async void OnOptionsChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        if (e?.PropertyName == "ZIsUp")
        {
            Camera.SwapCameraUp();
            await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
        }
        if (e?.PropertyName == "IsProjectionCamera")
            Options.AdjustCameraProjectionParameters();
        await SendOptionsToJavaScriptAsync(false);
        await InvokeAsync(StateHasChanged);
    }

    private void OnPickingRayRun(Ray pickingRay)
    {
        // Example: Log the ray information
        Console.WriteLine($"Picking ray created:");
        Console.WriteLine($"  Origin: ({pickingRay.Anchor.X:F3}, {pickingRay.Anchor.Y:F3}, {pickingRay.Anchor.Z:F3})");
        Console.WriteLine($"  Direction: ({pickingRay.Direction.X:F3}, {pickingRay.Direction.Y:F3}, {pickingRay.Direction.Z:F3})");

        // TODO: Implement triangle intersection testing here
        // You can iterate through your meshes and test ray-triangle intersections
        // using algorithms like Möller-Trumbore or similar
    }

    /// <summary>
    /// Updates the bounding spheres when adding a new object.
    /// </summary>
    /// <param name="mesh">The mesh to update spheres for.</param>
    /// <param name="sphere">The sphere to update.</param>
    /// <returns>True if spheres were updated, otherwise false.</returns>
    private bool UpdateSpheresAdd(AbstractObject3D obj3D)
    {
        var sphere = MinimumSphere.Run(obj3D.Vertices);
        objectSpheres[obj3D] = sphere;
        var needToUpdate = !Sphere.AContainsB(totalSphere, sphere);
        if (needToUpdate) // if totalSphere does not contain sphere
        {
            var newTotalSphere = MinimumSphere.Run(objectSpheres.Keys.SelectMany(o => o.Vertices));
            needToUpdate = !Sphere.IsPracticallySame(newTotalSphere, totalSphere);
            if (needToUpdate)
                totalSphere = newTotalSphere;
        }
        return needToUpdate;
    }

    /// <summary>
    /// Updates the bounding spheres for the given mesh and sphere.
    /// </summary>
    /// <param name="mesh">The mesh to update spheres for.</param>
    /// <param name="sphere">The sphere to update.</param>
    /// <returns>True if spheres were updated, otherwise false.</returns>
    private bool UpdateSpheresRemove(AbstractObject3D obj3D)
    {
        var sphere = objectSpheres[obj3D];
        objectSpheres.Remove(obj3D);
        var needToUpdate = obj3D.Vertices.Any(v => !Sphere.OnSurface(totalSphere, v));
        if (needToUpdate) // if totalSphere does not contain sphere
        {
            var newTotalSphere = MinimumSphere.Run(objectSpheres.Keys.SelectMany(o => o.Vertices));
            needToUpdate = !Sphere.IsPracticallySame(newTotalSphere, totalSphere);
            if (needToUpdate)
                totalSphere = newTotalSphere;
        }
        return needToUpdate;
    }
}
