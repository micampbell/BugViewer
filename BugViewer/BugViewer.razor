@using System.Numerics
@using System.Drawing
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using Microsoft.FluentUI.AspNetCore.Components
@using Icons = Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24
@inject IJSRuntime JS
@implements IAsyncDisposable

<div @ref="_containerRef" tabindex="0" @onkeydown="OnKeyDown" @onkeyup="OnKeyUp" @onkeydown:stopPropagation="true" class="page-container" style="width:@Width; height:@Height; position:relative;" @onmousedown="() => _isMouseButtonDown = true" @onmouseup="() => _isMouseButtonDown = false" @onmouseleave="() => _isMouseButtonDown = false">
    <canvas id="webgpu-canvas"
            class="webgpu-canvas"
            style="height:100%; width:100%;"
            @ref="_canvasRef"
            @onpointerdown="OnPointerDown"
            @onpointermove="OnPointerMove"
            @onpointerup="OnPointerUp"
            @onwheel="OnWheel"
            @onwheel:preventDefault="true"
            @oncontextmenu:preventDefault="true">
    </canvas>
    <!-- A small anchor button to toggle the popover -->
    <FluentStack Style="position:absolute; top:4px; left:4px; z-index:1001"
                 Class="@($"toolbar-buttons {(_isMouseButtonDown ? "mouse-down" : "")} {(IsAnyPopoverOpen ? "popover-open" : "")}")">
        <FluentButton Id="options"
                      Appearance="Appearance.Stealth"
                      Title="Open Options"
                      OnClick="@(() => ShowOptionsPanel())">
            <FluentIcon Value="@(new Icons.Settings())" />
        </FluentButton>
        <FluentButton Id="camera-controls"
                      Appearance="Appearance.Stealth"
                      Title="Open Camera Controls"
                      OnClick="@(() => ShowCameraPanel())">
            <FluentIcon Value="@(new Icons.CameraSparkles())" />
        </FluentButton>
        <FluentButton Id="help"
                      Appearance="Appearance.Stealth"
                      Title="Open Help"
                      OnClick="@(() => ShowHelpPanel())">
            <FluentIcon Value="@(new Icons.Question())" />
        </FluentButton>
    </FluentStack>

    <FluentPopover AnchorId="camera-controls"
                   Style="width:50px;"
                   @bind-Open="_cameraPopover"
                   HorizontalPosition="HorizontalPosition.Right">
        <Body>
            <FluentStack Orientation="Orientation.Vertical">
                <FluentButton OnClick="HandleCameraReset" Appearance="Appearance.Stealth" Title="Reset Camera" Class="toolbar-btn reset-btn"><FluentIcon Value="@(new Icons.CameraSwitch())" /></FluentButton>
                <FluentButton OnClick="@(() => HandleCameraCardinalView(CardinalDirection.NegativeX))" Appearance="Appearance.Stealth" Title="View -X" Class="toolbar-btn cardinal-btn">-X</FluentButton>
                <FluentButton OnClick="@(() => HandleCameraCardinalView(CardinalDirection.PositiveX))" Appearance="Appearance.Stealth" Title="View +X" Class="toolbar-btn cardinal-btn">+X</FluentButton>
                <FluentButton OnClick="@(() => HandleCameraCardinalView(CardinalDirection.NegativeY))" Appearance="Appearance.Stealth" Title="View -Y" Class="toolbar-btn cardinal-btn">-Y</FluentButton>
                <FluentButton OnClick="@(() => HandleCameraCardinalView(CardinalDirection.PositiveY))" Appearance="Appearance.Stealth" Title="View +Y" Class="toolbar-btn cardinal-btn">+Y</FluentButton>
                <FluentButton OnClick="@(() => HandleCameraCardinalView(CardinalDirection.NegativeZ))" Appearance="Appearance.Stealth" Title="View -Z" Class="toolbar-btn cardinal-btn">-Z</FluentButton>
                <FluentButton OnClick="@(() => HandleCameraCardinalView(CardinalDirection.PositiveZ))" Appearance="Appearance.Stealth" Title="View +Z" Class="toolbar-btn cardinal-btn">+Z</FluentButton>
            </FluentStack>
        </Body>
    </FluentPopover>
    <FluentPopover AnchorId="options"
                   Style="width:360px;"
                   @bind-Open="_optionsPopover"
                   HorizontalPosition="HorizontalPosition.Right">
        <Body>
            <div style="max-height:70vh; overflow-y: auto;">
                <FluentStack Orientation="Orientation.Vertical">
                    <FluentAccordion>
                        <FluentAccordionItem Heading="Lighting">
                            <FluentRadioGroup @bind-Value="Options.IsDarkTheme">
                                <FluentRadio Value="false">Light</FluentRadio>
                                <FluentRadio Value="true">Dark</FluentRadio>
                            </FluentRadioGroup>
                            <FluentLabel>Color Theme</FluentLabel>
                            <FluentStack Orientation="Orientation.Vertical" Style="width:100%;">
                                <label>Clear Color</label>
                                <input type="color" style="width:100%;" @bind="Options.ClearColor" @bind:event="oninput" />
                            </FluentStack>
                            <FluentSlider Label="Light Polar Angle" @bind-Value="Options.LightPolarAngle" Min="0" Max="3.14" Step="0.01" />
                            <FluentSlider Label="Light Azimuthal" @bind-Value="Options.LightAzimuthAngle" Min="1" Max="6.28" Step="0.01" />
                            <FluentSlider Label="Ambient Light" @bind-Value="Options.AmbientLight" Min="0" Max="1" Step="0.01" />
                            <FluentSlider Label="SpecularPower" @bind-Value="Options.SpecularPower" Min="1" Max="100" Step="0.25" />
                            <FluentSelect Items=@_sampleCountItems Label="MSAA Sample Count"
                                          TOption="Option<int>"
                                          OptionText="@(i => i.Text)"
                                          OptionValue="@(i => i.Value.ToString())"
                                          @bind-SelectedOption="@selectedIntOption" ValueChanged="SampleCountOptionChanged" />
                        </FluentAccordionItem>
                    </FluentAccordion>
                    <FluentAccordion>
                        <FluentAccordionItem Heading="📐 Grid">
                            <FluentStack Orientation="Orientation.Vertical">
                                <FluentSlider Label="Coordinate Thickness" @bind-Value="Options.CoordinateThickness" Min="0" Max="10" Step="0.1" />
                                <FluentSlider Label="Grid Size" @bind-Value="Options.GridSize" Min="50" Max="1000" Step="1" />
                                <FluentSlider Label="Grid Spacing" @bind-Value="Options.GridSpacing" Min="1" Max="100" Step="0.5" />
                                <FluentSlider Label="Line Width X" @bind-Value="Options.LineWidthX" Min="0" Max="1" Step="0.01" />
                                <FluentSlider Label="Line Width Y" @bind-Value="Options.LineWidthY" Min="0" Max="1" Step="0.01" />
                                <label>Grid Line Color</label>
                                <input type="color" style="width:100%;" @bind="Options.LineColor" @bind:event="oninput" />
                                <FluentSlider Label="Line Transparency" @bind-Value="Options.LineTransparency" Min="0" Max="1" Step="0.01" />
                                <label>Grid Base Color</label>
                                <input type="color" style="width:100%;" @bind="Options.BaseColor" @bind:event="oninput" />
                                <FluentSlider Label="Base Transparency" @bind-Value="Options.BaseTransparency" Min="0" Max="1" Step="0.01" />
                            </FluentStack>
                        </FluentAccordionItem>
                    </FluentAccordion>
                    <FluentAccordion>
                        <FluentAccordionItem Heading="📷 Camera">
                            <FluentStack Orientation="Orientation.Vertical">
                                <FluentRadioGroup @bind-Value="Options.ZIsUp">
                                    <FluentRadio Value="false">Y is Up</FluentRadio>
                                    <FluentRadio Value="true">Z is Up</FluentRadio>
                                </FluentRadioGroup>
                                <FluentLabel>Which Coordinate is Up?</FluentLabel>
                                <FluentRadioGroup @bind-Value="Options.IsProjectionCamera">
                                    <FluentRadio Value="true">Perspective</FluentRadio>
                                    <FluentRadio Value="false">Orthographic</FluentRadio>
                                </FluentRadioGroup>
                                <FluentLabel>Projection vs Ortho</FluentLabel>

                                <FluentStack>
                                    @if (Options.IsProjectionCamera)
                                    {
                                        <FluentSlider Label="Field of View" @bind-Value="Options.Fov" Min="1" Max="179" Step="0.5" />
                                    }
                                    else
                                    {
                                        <FluentLabel>Orthographic Size: @Options.OrthoSize.ToString("F2")</FluentLabel>
                                        <FluentSlider @bind-Value="Options.OrthoSize" Min="1" Max="999" Step="0.5" />
                                    }
                                </FluentStack>
                                <FluentLabel>Near: @Options.ZNear.ToString("F5")</FluentLabel>
                                <FluentSlider @bind-Value="Options.ZNear" Min="0.00001" Max="1" Step="0.001" />
                                <FluentLabel>Far: @Options.ZFar.ToString("F0")</FluentLabel>
                                <FluentSlider @bind-Value="Options.ZFar" Min="10" Max="9999" Step="1" />
                                <FluentCheckbox @bind-Value="Options.ConstrainPolar" Label="Constrain Polar" />
                                @if (Options.ConstrainPolar)
                                {
                                    <FluentLabel>Max Polar: @((Options.MaxPolar * 180 / Math.PI).ToString("F0"))°</FluentLabel>
                                    <FluentSlider @bind-Value="Options.MaxPolar" Min="0" Max="@(Math.PI * 0.5)" Step="0.01" />
                                    <FluentLabel>Min Polar: @((Options.MinPolar * 180 / Math.PI).ToString("F0"))°</FluentLabel>
                                    <FluentSlider @bind-Value="Options.MinPolar" Min="@(-Math.PI * 0.5)" Max="0" Step="0.01" />
                                }
                                <FluentCheckbox @bind-Value="Options.ConstrainAzimuth" Label="Constrain Azimuth" />
                                @if (Options.ConstrainAzimuth)
                                {
                                    <FluentLabel>Max Azimuth: @((Options.MaxAzimuth * 180 / Math.PI).ToString("F0"))°</FluentLabel>
                                    <FluentSlider @bind-Value="Options.MaxAzimuth" Min="@(-Math.PI)" Max="@Math.PI" Step="0.01" />
                                    <FluentLabel>Min Azimuth: @((Options.MinAzimuth * 180 / Math.PI).ToString("F0"))°</FluentLabel>
                                    <FluentSlider @bind-Value="Options.MinAzimuth" Min="@(-Math.PI)" Max="@Math.PI" Step="0.01" />
                                }
                                <FluentCheckbox @bind-Value="Options.ConstrainDistance" Label="Constrain Distance" />
                                @if (Options.ConstrainDistance)
                                {
                                    <FluentLabel>Max Distance: @Options.MaxDistance.ToString("F1")</FluentLabel>
                                    <FluentSlider @bind-Value="Options.MaxDistance" Min="1" Max="1000" Step="0.5" />
                                    <FluentLabel>Min Distance: @Options.MinDistance.ToString("F2")</FluentLabel>
                                    <FluentSlider @bind-Value="Options.MinDistance" Min="0.1" Max="10" Step="0.1" />
                                }
                                <FluentLabel>Orbit Sensitivity: @Options.OrbitSensitivity.ToString("F5")</FluentLabel>
                                <FluentSlider @bind-Value="Options.OrbitSensitivity" Min="0.001" Max="0.1" Step="0.001" />
                                <FluentLabel>Zoom Sensitivity: @Options.ZoomSensitivity.ToString("F5")</FluentLabel>
                                <FluentSlider @bind-Value="Options.ZoomSensitivity" Min="0.0001" Max="0.01" Step="0.0001" />
                                <FluentLabel>Pan Sensitivity: @Options.PanSensitivity.ToString("F5")</FluentLabel>
                                <FluentSlider @bind-Value="Options.PanSensitivity" Min="0.0001" Max="0.01" Step="0.001" />
                                <FluentLabel>Pan Speed (Shift): @Options.PanSpeedMultiplier.ToString("F1")</FluentLabel>
                                <FluentSlider @bind-Value="Options.PanSpeedMultiplier" Min="1" Max="10" Step="0.5" />
                            </FluentStack>
                        </FluentAccordionItem>
                    </FluentAccordion>
                </FluentStack>
            </div>
        </Body>
    </FluentPopover>
    <FluentPopover AnchorId="help"
                   Style="width:300px;"
                   @bind-Open="_helpPopover"
                   HorizontalPosition="HorizontalPosition.Right">
        <Body>
            <h4>🎮 Camera Controls</h4>
            <div class="control-group">
                <strong>🖱️ Mouse:</strong>
                <ul>
                    <li><strong>Left Drag:</strong> Rotate</li>
                    <li><strong>Right Drag:</strong> Pan</li>
                    <li><strong>Wheel:</strong> Zoom</li>
                    <li><strong>Double-Click:</strong> Pick</li>
                </ul>
            </div>
            <div class="control-group">
                <strong>⌨️ Keyboard:</strong>
                <ul>
                    <li><strong>W/S:</strong> Forward / Back</li>
                    <li><strong>A/D:</strong> Left / Right</li>
                    <li><strong>Q/E:</strong> Down / Up</li>
                    <li><strong>Shift:</strong> Faster</li>
                    <li><strong>.</strong> Toggle Panel</li>
                </ul>
            </div>
        </Body>
    </FluentPopover>

</div>

<style>
    .toolbar-buttons {
        animation: fadeToTransparent 5s ease-in-out forwards;
    }

        .toolbar-buttons:hover:not(.mouse-down),
        .toolbar-buttons.popover-open {
            animation: none;
            opacity: 1 !important;
        }

    @@keyframes fadeToTransparent {
        from {
            opacity: 1;
        }

        to {
            opacity: 0.001;
        }
    }
</style>

@code {
    private bool _cameraPopover = false;
    private bool _optionsPopover = false;
    private bool _helpPopover = false;
    private bool IsAnyPopoverOpen => _cameraPopover || _optionsPopover || _helpPopover;
    private bool _isMouseButtonDown;

    [Parameter]
    public string Width { get; set; } = "100%";

    [Parameter]
    public string Height { get; set; } = "100vh";

    private ElementReference? _containerRef;
    private ElementReference? _canvasRef;
    private BugViewerOptions _options;

    [Parameter]
    public BugViewerOptions Options
    {
        get => _options;
        set
        {
            if (!ReferenceEquals(_options, value))
            {
                _options = value;
                _options.PropertyChanged += OnOptionsChanged;
            }
        }
    }

    [Parameter]
    public EventCallback OnReady { get; set; }
    [Parameter]
    public EventCallback OnTriangleSelected { get; set; }

    public OrbitCamera? Camera { get; private set; }

    private IJSObjectReference? _module;
    private DotNetObjectReference<BugViewer>? _dotNetRef;
    private bool _ready;
    private string? _error;
    private bool _isDragging;
    private bool _isPanning;
    private double _lastPointerX;
    private double _lastPointerY;
    private HashSet<string> _pressedKeys = new();
    private System.Threading.Timer? _keyboardMoveTimer;
    private Sphere totalSphere;
    private Dictionary<AbstractObject3D, Sphere> objectSpheres = new();
    private List<MeshData> meshes = new();
    private List<LineData> lines = new();
    private List<MeshData> billBoards = new();
    private HashSet<string> sentMeshIds = new();
    private bool _moduleInitialized = false;
    private double _canvasWidth = 800;
    private double _canvasHeight = 600;
    private DateTime _lastClickTime = DateTime.MinValue;
    private double _lastClickX;
    private double _lastClickY;
    private const double DoubleClickTimeMs = 300;
    private const double DoubleClickDistancePx = 5;
    public double LatestFrameMs { get; private set; }

    public string SelectedMeshName { get; private set; } = null;
    public int SelectedTriangleInMeshIndex { get; private set; } = -1;
    List<string> triangleToMesh = new();
    List<int> triangleToInMeshIndex = new();
    List<float> facePlaneDistances = new();
    List<Vector3> faceNormals = new();
    List<Vector3> bCoords = new();
    List<Vector3> uBarycentricMultipliers = new();
    List<Vector3> vBarycentricMultipliers = new();

    Option<int>? selectedIntOption;
    private List<Option<int>> _sampleCountItems = new()
    {
        new() { Value = 1, Text = "1x (No MSAA)" },
        // new() { Value = 2, Text = "2x" },  //generally not supported
        new() { Value = 4, Text = "4x MSAA" },
        new() { Value = 8, Text = "8x MSAA" }
    };
    private void SampleCountOptionChanged(string args)
    {
        Options.SampleCount = int.Parse(args);
    }


    protected override void OnInitialized()
    {
        if (Options is null)
        {
            Options = BugViewerOptions.DefaultLight;
        }

        Camera = new OrbitCamera(Vector3.Zero, Options);
        _keyboardMoveTimer = new System.Threading.Timer(_ => ProcessKeyboardMovement(), null, 0, 16);
    }



    private void OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Escape")
        {
            _cameraPopover = false;
            _optionsPopover = false;
            _helpPopover = false;
            _pressedKeys.Clear();
            StateHasChanged();
            return;
        }
        if (e.Key == ",")
        {
            ShowOptionsPanel();
            _pressedKeys.Clear();
            return;
        }

        if (e.Key == ".")
        {
            ShowCameraPanel();
            _pressedKeys.Clear();
            return;
        }

        if (e.Key == "?" || (e.Key == "/"))
        {
            ShowHelpPanel();
            _pressedKeys.Clear();
            return;
        }
        if (IsAnyPopoverOpen) return;

        _pressedKeys.Add(e.Key.ToLower());
    }

    private void ShowOptionsPanel()
    {
        _optionsPopover = !_optionsPopover;
        _helpPopover = false;
        _cameraPopover = false;
    }

    private void ShowHelpPanel()
    {
        _optionsPopover = false;
        _helpPopover = !_helpPopover;
        _cameraPopover = false;
    }

    private void ShowCameraPanel()
    {
        _optionsPopover = false;
        _helpPopover = false;
        _cameraPopover = !_cameraPopover;
    }

    private void OnKeyUp(KeyboardEventArgs e)
    {
        _pressedKeys.Remove(e.Key.ToLower());
    }

    private void OnPointerDown(PointerEventArgs e)
    {
        _containerRef?.FocusAsync();
        var currentTime = DateTime.Now;
        var timeSinceLast = (currentTime - _lastClickTime).TotalMilliseconds;
        var dist = Math.Sqrt(Math.Pow(e.ClientX - _lastClickX, 2) + Math.Pow(e.ClientY - _lastClickY, 2));

        if (e.Button == 0 && timeSinceLast <= DoubleClickTimeMs && dist <= DoubleClickDistancePx)
        {
            OnDoubleClick(e);
            return;
        }

        if (e.Button == 0)
        {
            _lastClickTime = currentTime;
            _lastClickX = e.ClientX;
            _lastClickY = e.ClientY;
            _isDragging = true;
            _isPanning = false;
            _lastPointerX = e.ClientX;
            _lastPointerY = e.ClientY;
        }
        else if (e.Button == 2)
        {
            _isPanning = true;
            _isDragging = false;
            _lastPointerX = e.ClientX;
            _lastPointerY = e.ClientY;
        }
    }

    private async Task OnDoubleClick(PointerEventArgs e)
    {
        if (_module is null || !_ready)
        {
            return;
        }

        var rect = await _module.InvokeAsync<BoundingClientRect>("getBoundingClientRect", _canvasRef);
        var rx = e.ClientX - rect.Left;
        var ry = e.ClientY - rect.Top;
        if (Options.DoubleClickIsSelect)
        {
            if (!OnTriangleSelected.HasDelegate) return;
            (Vector3 anchor, Vector3 dirVector) = Camera.CreateRayFromScreenPoint(rx, ry, rect.Width, rect.Height);
            if (DoesRayGoThroughTriangle(anchor, dirVector, out var meshName, out var meshIndex, out var distance, out var point))
            {
                SelectedMeshName = meshName;
                SelectedTriangleInMeshIndex = meshIndex;
                await OnTriangleSelected.InvokeAsync();
            }
        }
        else ResetCamera();
    }

    bool DoesRayGoThroughTriangle(Vector3 anchor, Vector3 dirVector, out string meshName, out int meshIndex, out float distance, out Vector3 point)
    {
        distance = float.MaxValue;
        meshIndex = -1;
        meshName = "";
        point = Vector3.Zero;
        for (int index = 0; index < triangleToMesh.Count; index++)
        {
            var normal = faceNormals[index];
            if (Vector3.Dot(normal, dirVector) >= 0)
                continue; // ignore back faces
            var faceDistance = facePlaneDistances[index];
            var uBaryFactor = uBarycentricMultipliers[index];
            var vBaryFactor = vBarycentricMultipliers[index];
            var dot = Vector3.Dot(dirVector, normal);

            var anchorDistanceToPlane = faceDistance - Vector3.Dot(anchor, normal);
            var thisDistance = anchorDistanceToPlane / dot;
            if (thisDistance < 0 || thisDistance >= distance)
                continue;
            var thisPoint = anchor + distance * dirVector; // yes, it is normally '+' but in the previous line

            var wVector = thisPoint - bCoords[index];
            var u = Vector3.Dot(wVector, uBaryFactor);
            if (u <= 0 || u >= 1) continue;
            var v = Vector3.Dot(wVector, vBaryFactor);
            if (v <= 0 || v >= 1) continue;
            if (u + v > 1) continue;
            // yes intersecting!
            distance = thisDistance;
            meshName = triangleToMesh[index];
            meshIndex = triangleToInMeshIndex[index];
            point = thisPoint;
        }
        return meshIndex != -1;
    }

    private class BoundingClientRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    private async Task OnPointerMove(PointerEventArgs e)
    {
        if (_isDragging)
        {
            var dx = e.ClientX - _lastPointerX;
            var dy = e.ClientY - _lastPointerY;
            _lastPointerX = e.ClientX;
            _lastPointerY = e.ClientY;
            Camera.Orbit(dx, dy);

            if (_module != null && _ready)
            {
                await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
            }
        }
        else if (_isPanning)
        {
            var dx = e.ClientX - _lastPointerX;
            var dy = e.ClientY - _lastPointerY;
            _lastPointerX = e.ClientX;
            _lastPointerY = e.ClientY;
            Camera.PanWithMouse(dx, dy, e.ShiftKey);

            if (_module != null && _ready)
            {
                await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
            }
        }
    }

    private void OnPointerUp(PointerEventArgs e)
    {
        if (e.Button == 0)
        {
            _isDragging = false;
        }
        else if (e.Button == 2)
        {
            _isPanning = false;
        }
    }

    private async Task OnWheel(WheelEventArgs e)
    {
        Camera.Zoom(e.DeltaY);

        if (_module != null && _ready)
        {
            await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
        }
    }

    private async void ProcessKeyboardMovement()
    {
        if (_pressedKeys.Count == 0 || _module == null || !_ready)
        {
            return;
        }

        double forward = 0, right = 0, up = 0;
        bool shift = _pressedKeys.Contains("shift");

        if (_pressedKeys.Contains("w"))
        {
            forward += 1;
        }

        if (_pressedKeys.Contains("s"))
        {
            forward -= 1;
        }

        if (_pressedKeys.Contains("d"))
        {
            right += 1;
        }

        if (_pressedKeys.Contains("a"))
        {
            right -= 1;
        }

        if (_pressedKeys.Contains("q"))
        {
            up -= 1;
        }

        if (_pressedKeys.Contains("e"))
        {
            up += 1;
        }

        if (forward != 0 || right != 0 || up != 0)
        {
            Camera.PanWithKeyboard(forward, right, up, shift);

            try
            {
                await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
            }
            catch
            {
                // Handle error silently
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }
        if (_containerRef.HasValue)
        {
            await _containerRef.Value.FocusAsync();
        }

        try
        {
            _module = await JS.InvokeAsync<IJSObjectReference>("import", $"/_content/BugViewer/js/webgpu-canvas.js?v={DateTime.UtcNow.Ticks}");
        }
        catch (JSException jse)
        {
            _error = $"Failed to import webgpu module: {jse.Message}";
            StateHasChanged();
            return;
        }
        catch (Exception ex)
        {
            _error = $"Unexpected error importing webgpu module: {ex.Message}";
            StateHasChanged();
            return;
        }

        _dotNetRef = DotNetObjectReference.Create(this);

        try
        {
            await SendOptionsToJavaScriptAsync(true);
        }
        catch (Exception ex)
        {
            _error = $"Error initializing WebGPU canvas: {ex.Message}";
            StateHasChanged();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        await SendOptionsToJavaScriptAsync(false);
    }

    private async Task SendOptionsToJavaScriptAsync(bool init)
    {
        if (_module is null)
        {
            return;
        }

        if (init)
        {
            await _module.InvokeVoidAsync("initGPU_Canvas", _dotNetRef, _canvasRef, Options.ToJavascriptOptions(), Camera.ConvertMatrixToJavaScript());
        }
        else
        {
            await _module.InvokeVoidAsync("updateDisplayOptions", Options.ToJavascriptOptions());
            await SendProjectionMatrixToJavaScriptAsync();
        }
    }

    [JSInvokable]
    public Task OnFrameMsUpdate(double ms)
    {
        LatestFrameMs = ms;
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnWebGpuReady()
    {
        _ready = true;
        _error = null;

        // send any queued options/projection
        await SendProjectionMatrixToJavaScriptAsync();

        // Mark module initialized and flush any queued meshes
        _moduleInitialized = true;
        if (_module != null)
        {
            try
            {
                foreach (var m in meshes)
                {
                    if (!sentMeshIds.Contains(m.Id))
                    {
                        await _module.InvokeVoidAsync("addMesh", m.CreateJavascriptData());
                        sentMeshIds.Add(m.Id);
                    }
                }

                foreach (var l in lines)
                {
                    await _module.InvokeVoidAsync("addLines", l.CreateJavascriptData());
                }

                foreach (var b in billBoards)
                {
                    await _module.InvokeVoidAsync("addTextBillboard", b.CreateJavascriptData());
                }
            }
            catch (JSException jsEx)
            {
                Console.Error.WriteLine(jsEx.Message);
            }
        }

        StateHasChanged();

        if (OnReady.HasDelegate)
        {
            await OnReady.InvokeAsync();
        }
    }

    [JSInvokable]
    public Task OnWebGpuError(string message)
    {
        _ready = false;
        _error = message;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnCanvasResized(double w, double h)
    {
        _canvasWidth = w;
        _canvasHeight = h;
        await SendProjectionMatrixToJavaScriptAsync();
    }

    private async Task SendProjectionMatrixToJavaScriptAsync()
    {
        if (_module is null || !_ready || Camera is null)
        {
            return;
        }

        try
        {
            var proj = Camera.ConvertProjectionMatrixToJavaScript(_canvasWidth, _canvasHeight);
            await _module.InvokeVoidAsync("writeProjectionMatrix", proj);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine(ex.Message);
        }
    }

    public async ValueTask DisposeAsync()
    {
        //Camera = new OrbitCamera(Camera.Target, Options);
        _keyboardMoveTimer?.Dispose();
        Options.PropertyChanged -= OnOptionsChanged;

        if (_module != null)
        {
            try
            {
                await _module.InvokeVoidAsync("disposeWebGPU_Canvas");
            }
            catch
            {
                // Handle error silently
            }

            try
            {
                await _module.DisposeAsync();
            }
            catch
            {
                // Handle error silently
            }
        }

        _dotNetRef?.Dispose();
    }

    public void ResetCamera()
    {
        Camera.Reset(totalSphere);
        _module?.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
    }

    private async Task HandleCameraReset()
    {
        ResetCamera();
    }

    private async Task HandleCameraCardinalView(CardinalDirection dir)
    {
        if (Camera is null)
        {
            return;
        }

        ResetCamera();
        Camera.SetCardinalView(dir);

        if (_module != null && _ready)
        {
            await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
        }
    }

    private async void OnOptionsChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        if (e?.PropertyName == nameof(Options.ZIsUp))
        {
            Camera.SwapCameraUp();
            await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
        }

        if (e?.PropertyName == nameof(Options.IsProjectionCamera))
        {
            Options.AdjustCameraProjectionParameters();
        }

        if (e?.PropertyName == nameof(Options.IsDarkTheme) && Options.AutoResetOnThemeChange)
        {
            Options.ResetToDefault(Options.IsDarkTheme);
        }

        StateHasChanged();
        await SendOptionsToJavaScriptAsync(false);
    }

    private async void UpdateViewer(bool sphereChanged)
    {
        if (Camera is null || _module is null)
        {
            return;
        }

        if ((sphereChanged && Options.AutoResetCamera == UpdateTypes.SphereChange) || Options.AutoResetCamera == UpdateTypes.OnDataChange)
        {
            ResetCamera();

            try
            {
                await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
            }
            catch
            {
                // Handle error silently
            }
        }

        if ((sphereChanged && Options.AutoUpdateGrid == UpdateTypes.SphereChange) || Options.AutoUpdateGrid == UpdateTypes.OnDataChange)
        {
            Options.GridSize = Options.AutoGridBuffer * (totalSphere.Center.Length() + totalSphere.GetRadius());
            OnOptionsChanged(null, null);
        }
    }

    private bool UpdateSpheresAdd(AbstractObject3D obj3D)
    {
        var sphere = MinimumSphere.Run(obj3D.Vertices);
        objectSpheres[obj3D] = sphere;
        var need = !Sphere.AContainsB(totalSphere, sphere);

        if (need)
        {
            var newSphere = MinimumSphere.Run(objectSpheres.Keys.SelectMany(o => o.Vertices));
            need = !Sphere.IsPracticallySame(newSphere, totalSphere);

            if (need)
            {
                totalSphere = newSphere;
            }
        }

        return need;
    }

    private bool UpdateSpheresRemove(AbstractObject3D obj3D)
    {
        var sphere = objectSpheres[obj3D];
        objectSpheres.Remove(obj3D);
        var need = obj3D.Vertices.Any(v => !Sphere.OnSurface(totalSphere, v));

        if (need)
        {
            var newSphere = MinimumSphere.Run(objectSpheres.Keys.SelectMany(o => o.Vertices));
            need = !Sphere.IsPracticallySame(newSphere, totalSphere);

            if (need)
            {
                totalSphere = newSphere;
            }
        }

        return need;
    }

    public async Task AddMeshAsync(MeshData mesh)
    {
        meshes.Add(mesh);
        UpdateViewer(UpdateSpheresAdd(mesh));
        for (int i = 0; i < mesh.Indices.Count; i++)
        {
            var tri = mesh.Indices[i];
            var a = mesh.Vertices[tri.a];
            var b = mesh.Vertices[tri.b];
            var c = mesh.Vertices[tri.c];
            var v1 = b - a;
            var v2 = c - b;
            var v1Sqd = v1.LengthSquared();
            var v2Sqd = v2.LengthSquared();
            var normal = Vector3.Normalize(Vector3.Cross(b - a, c - b));
            var dist = Vector3.Dot(normal, a);
            var v1Dotv2 = Vector3.Dot(v1, v2);
            var oneOverDenom = 1 / (v1Sqd * v2Sqd - v1Dotv2 * v1Dotv2);
            var uBaryMultiplier = Vector3.Multiply(oneOverDenom,
                Vector3.Multiply(v1Sqd, v2) - Vector3.Multiply(v1Dotv2, v1));
            var vBaryMultiplier = Vector3.Multiply(oneOverDenom,
                Vector3.Multiply(v2Sqd, v1) - Vector3.Multiply(v1Dotv2, v2));
            triangleToMesh.Add(mesh.Id);
            triangleToInMeshIndex.Add(i);
            facePlaneDistances.Add(dist);
            faceNormals.Add(normal);
            bCoords.Add(b);
            uBarycentricMultipliers.Add(uBaryMultiplier);
            vBarycentricMultipliers.Add(vBaryMultiplier);
        }

        // If module not ready yet, queue the mesh. It will be sent from OnWebGpuReady.
        if (_module is null || !_ready)
        {
            return;
        }

        // avoid duplicates
        if (!sentMeshIds.Contains(mesh.Id))
        {
            await _module.InvokeVoidAsync("addMesh", mesh.CreateJavascriptData());
            sentMeshIds.Add(mesh.Id);
        }
    }

    public async Task AddLinesAsync(LineData path)
    {
        lines.Add(path);
        UpdateViewer(UpdateSpheresAdd(path));

        if (_module is null || !_ready)
        {
            return;
        }

        // no id tracking for lines currently
        await _module.InvokeVoidAsync("addLines", path.CreateJavascriptData());
    }

    public async Task ChangeMeshColorAsync(MeshData mesh, System.Drawing.Color color)
    {
        var index = meshes.IndexOf(mesh);
        if (index < 0)
        {   // logger.LogError("Mesh not found in viewer");
            return;
        }
        if (meshes[index].ColorMode != MeshColoring.UniformColor)
        {   // logger.LogError("Mesh not found in viewer");
            return;
        }

        // Update the C# model so if it's sent later (or re-sent), it has the new color
        meshes[index].Colors = new[] { color };

        // now call JS to change color of the mesh at index if ready
        if (_module != null && _ready)
        {
            await _module.InvokeVoidAsync("changeMeshColor",
                    new
                    {
                        index = index,
                        color = new float[]
                        {
                        color.R / 255f,
                        color.G / 255f,
                        color.B / 255f,
                        color.A / 255f
                        }
                    });
        }
    }
    public async Task RemoveMeshAsync(MeshData mesh)
    {
        // Find index before removing so we can tell JS which mesh to remove
        var index = meshes.IndexOf(mesh);
        if (index < 0)
            return;

        // Remove from the C# list and update viewer bounds
        meshes.RemoveAt(index);
        UpdateViewer(UpdateSpheresRemove(mesh));

        if (_module is null || !_ready)
        {
            // nothing sent yet or module not ready; ensure we don't try to remove on JS
            sentMeshIds.Remove(mesh.Id);
            return;
        }

        try
        {
            // If the mesh was already sent to JS, ask JS to remove by index.
            // The JS side will destroy GPU resources and splice the meshes array.
            if (sentMeshIds.Contains(mesh.Id))
            {
                await _module.InvokeVoidAsync("removeMesh", index);
                sentMeshIds.Remove(mesh.Id);
            }
        }
        catch
        {
            // If remove by index fails for any reason, fall back to rebuilding the JS scene
            try
            {
                await _module.InvokeVoidAsync("clearAllMeshes");
                sentMeshIds.Clear();
                foreach (var m in meshes)
                {
                    await _module.InvokeVoidAsync("addMesh", m.CreateJavascriptData());
                    sentMeshIds.Add(m.Id);
                }
            }
            catch
            {
                // ignore errors
            }
        }
    }

    public async Task ClearAllMeshesAsync()
    {
        if (meshes.Count == 0)
        {
            return;
        }

        meshes.Clear();
        sentMeshIds.Clear();
        UpdateViewer(true);

        if (_module is null || !_ready)
        {
            return;
        }

        await _module.InvokeVoidAsync("clearAllMeshes");
    }

    public async Task ClearAllLinesAsync()
    {
        if (lines.Count == 0)
        {
            return;
        }

        var need = lines.All(l => UpdateSpheresRemove(l));
        lines.Clear();
        UpdateViewer(need);
        await _module.InvokeVoidAsync("clearAllLines");
    }

    public async Task AddTextBillboardAsync(string id, string text, Vector3 position, System.Drawing.Color backgroundColor, System.Drawing.Color textColor)
    {
        if (_module is null || !_ready)
        {
            throw new InvalidOperationException("Not ready");
        }

        var billboardData = new TextBillboard
        {
            BackgroundColor = backgroundColor,
            TextColor = textColor,
            Text = text,
            Vertices = new List<Vector3> { position },
            Id = id
        };

        await _module.InvokeVoidAsync("addTextBillboard", billboardData.CreateJavascriptData());
    }

    public async Task RemoveTextBillboardAsync(string id)
    {
        if (_module is null)
        {
            return;
        }

        await _module.InvokeVoidAsync("removeTextBillboard", id);
    }

    public async Task ClearAllTextBillboardsAsync()
    {
        if (_module is null)
        {
            return;
        }

        await _module.InvokeVoidAsync("clearAllTextBillboards");
    }
}