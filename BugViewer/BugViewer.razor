@using System.Numerics
@using System.Drawing
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using Microsoft.FluentUI.AspNetCore.Components
@using Icons = Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24
@inject IJSRuntime JS
@implements IAsyncDisposable

<div class="page-container" style="width:@Width; height:@Height;" @onmousedown="() => _isMouseButtonDown = true" @onmouseup="() => _isMouseButtonDown = false" @onmouseleave="() => _isMouseButtonDown = false">
    <canvas id="webgpu-canvas"
            class="webgpu-canvas"
            style="height:100%; width:100%;"
            tabindex="0"
            @ref="_canvasRef"
            @onpointerdown="OnPointerDown"
            @onpointermove="OnPointerMove"
            @onpointerup="OnPointerUp"
            @onwheel="OnWheel"
            @onwheel:preventDefault="true"
            @onkeydown="OnKeyDown"
            @onkeyup="OnKeyUp"
            @oncontextmenu:preventDefault="true">
    </canvas>
    <!-- A small anchor button to toggle the popover -->
        <FluentStack Style="position:absolute; top:4px; left:4px; z-index:1001"
                 Class="@($"toolbar-buttons {(_isMouseButtonDown ? "mouse-down" : "")} {(IsAnyPopoverOpen ? "popover-open" : "")}")">
        <FluentButton Id="options"
                      Appearance="Appearance.Stealth"
                      Title="Open Options"
                      OnClick="@(() => ShowOptionsPanel())">
            <FluentIcon Value="@(new Icons.Settings())" />
        </FluentButton>
        <FluentButton Id="camera-controls"
                      Appearance="Appearance.Stealth"
                      Title="Open Camera Controls"
                      OnClick="@(() => ShowCameraPanel())">
            <FluentIcon Value="@(new Icons.CameraSparkles())" />
        </FluentButton>
        <FluentButton Id="help"
                      Appearance="Appearance.Stealth"
                      Title="Open Help"
                      OnClick="@(() => ShowHelpPanel())">
            <FluentIcon Value="@(new Icons.Question())" />
        </FluentButton>
    </FluentStack>

    <FluentPopover AnchorId="camera-controls"
                   Style="width:50px;"
                   @bind-Open="_cameraPopover"
                   HorizontalPosition="HorizontalPosition.Right">
        <Body>
            <FluentStack>
                <FluentButton OnClick="HandleCameraReset" Appearance="Appearance.Stealth" Title="Reset Camera" Class="toolbar-btn reset-btn"><FluentIcon Value="@(new Icons.CameraSwitch())" /></FluentButton>
                <FluentButton OnClick="@(() => HandleCameraCardinalView(CardinalDirection.NegativeX))" Appearance="Appearance.Stealth" Title="View -X" Class="toolbar-btn cardinal-btn">-X</FluentButton>
                <FluentButton OnClick="@(() => HandleCameraCardinalView(CardinalDirection.PositiveX))" Appearance="Appearance.Stealth" Title="View +X" Class="toolbar-btn cardinal-btn">+X</FluentButton>
                <FluentButton OnClick="@(() => HandleCameraCardinalView(CardinalDirection.NegativeY))" Appearance="Appearance.Stealth" Title="View -Y" Class="toolbar-btn cardinal-btn">-Y</FluentButton>
                <FluentButton OnClick="@(() => HandleCameraCardinalView(CardinalDirection.PositiveY))" Appearance="Appearance.Stealth" Title="View +Y" Class="toolbar-btn cardinal-btn">+Y</FluentButton>
                <FluentButton OnClick="@(() => HandleCameraCardinalView(CardinalDirection.NegativeZ))" Appearance="Appearance.Stealth" Title="View -Z" Class="toolbar-btn cardinal-btn">-Z</FluentButton>
                <FluentButton OnClick="@(() => HandleCameraCardinalView(CardinalDirection.PositiveZ))" Appearance="Appearance.Stealth" Title="View +Z" Class="toolbar-btn cardinal-btn">+Z</FluentButton>
            </FluentStack>
        </Body>
    </FluentPopover>
    <FluentPopover AnchorId="options"
                   Style="width:360px;"
                   @bind-Open="_optionsPopover"
                   HorizontalPosition="HorizontalPosition.Right">
        <Body>
            <div style="max-height:70vh; overflow-y: auto;">
                <FluentStack>
                    <FluentAccordion>
                        <FluentAccordionItem Heading="Lighting">
                            <FluentStack Orientation="Orientation.Vertical" Style="width:100%;">
                                <label>Clear Color</label>
                                <input type="color" style="width:100%;" @bind="Options.ClearColor" @bind:event="oninput" />
                            </FluentStack>
                            <FluentSlider Label="Light Polar Angle" @bind-Value="Options.LightPolarAngle" Min="0" Max="3.14" Step="0.01" />
                            <FluentSlider Label="Light Azimuthal" @bind-Value="Options.LightAzimuthAngle" Min="1" Max="6.28" Step="0.01" />
                            <FluentSlider Label="Ambient Light" @bind-Value="Options.AmbientLight" Min="0" Max="1" Step="0.01" />
                            <FluentSlider Label="SpecularPower" @bind-Value="Options.SpecularPower" Min="1" Max="100" Step="0.25" />
                            <FluentSelect Items=@_sampleCountItems Label="MSAA Sample Count"
                                          TOption="Option<int>"
                                          OptionText="@(i => i.Text)"
                                          OptionValue="@(i => i.Value.ToString())"
                                          @bind-SelectedOption="@selectedIntOption" ValueChanged="SampleCountOptionChanged" />
                        </FluentAccordionItem>
                    </FluentAccordion>
                    <FluentAccordion>
                        <FluentAccordionItem Heading="📐 Grid">
                            <FluentStack Orientation="Orientation.Vertical">
                                <FluentSlider Label="Coordinate Thickness" @bind-Value="Options.CoordinateThickness" Min="0" Max="10" Step="0.1" />
                                <FluentSlider Label="Grid Size" @bind-Value="Options.GridSize" Min="50" Max="1000" Step="1" />
                                <FluentSlider Label="Grid Spacing" @bind-Value="Options.GridSpacing" Min="1" Max="100" Step="0.5" />
                                <FluentSlider Label="Line Width X" @bind-Value="Options.LineWidthX" Min="0" Max="1" Step="0.01" />
                                <FluentSlider Label="Line Width Y" @bind-Value="Options.LineWidthY" Min="0" Max="1" Step="0.01" />
                                <label>Grid Line Color</label>
                                <input type="color" style="width:100%;" @bind="Options.LineColor" @bind:event="oninput" />
                                <FluentSlider Label="Line Transparency" @bind-Value="Options.LineTransparency" Min="0" Max="1" Step="0.01" />
                                <label>Grid Base Color</label>
                                <input type="color" style="width:100%;" @bind="Options.BaseColor" @bind:event="oninput" />
                                <FluentSlider Label="Base Transparency" @bind-Value="Options.BaseTransparency" Min="0" Max="1" Step="0.01" />
                            </FluentStack>
                        </FluentAccordionItem>
                    </FluentAccordion>
                    <FluentAccordion>
                        <FluentAccordionItem Heading="📷 Camera">
                            <FluentStack Orientation="Orientation.Vertical">
                                <FluentSwitch Label="Which Coordinate is Up?" CheckedMessage="Z is Up" UncheckedMessage="Y is Up" @bind-Value="Options.ZIsUp" />
                                <FluentSwitch Label="Projection vs Ortho" CheckedMessage="Projection" UncheckedMessage="Orthographic" @bind-Value="Options.IsProjectionCamera" />
                                @if (Options.IsProjectionCamera)
                                {
                                    <FluentSlider Label="Field of View" @bind-Value="Options.Fov" Min="1" Max="179" Step="0.5" />
                                }
                                else
                                {
                                    <FluentLabel>Orthographic Size: @Options.OrthoSize.ToString("F2")</FluentLabel>
                                    <FluentSlider @bind-Value="Options.OrthoSize" Min="1" Max="999" Step="0.5" />
                                }
                                <FluentLabel>Near: @Options.ZNear.ToString("F5")</FluentLabel>
                                <FluentSlider @bind-Value="Options.ZNear" Min="0.00001" Max="1" Step="0.001" />
                                <FluentLabel>Far: @Options.ZFar.ToString("F0")</FluentLabel>
                                <FluentSlider @bind-Value="Options.ZFar" Min="10" Max="9999" Step="1" />
                                <FluentCheckbox @bind-Value="Options.ConstrainPolar" Label="Constrain Polar" />
                                @if (Options.ConstrainPolar)
                                {
                                    <FluentLabel>Max Polar: @((Options.MaxPolar * 180 / Math.PI).ToString("F0"))°</FluentLabel>
                                    <FluentSlider @bind-Value="Options.MaxPolar" Min="0" Max="@(Math.PI * 0.5)" Step="0.01" />
                                    <FluentLabel>Min Polar: @((Options.MinPolar * 180 / Math.PI).ToString("F0"))°</FluentLabel>
                                    <FluentSlider @bind-Value="Options.MinPolar" Min="@(-Math.PI * 0.5)" Max="0" Step="0.01" />
                                }
                                <FluentCheckbox @bind-Value="Options.ConstrainAzimuth" Label="Constrain Azimuth" />
                                @if (Options.ConstrainAzimuth)
                                {
                                    <FluentLabel>Max Azimuth: @((Options.MaxAzimuth * 180 / Math.PI).ToString("F0"))°</FluentLabel>
                                    <FluentSlider @bind-Value="Options.MaxAzimuth" Min="@(-Math.PI)" Max="@Math.PI" Step="0.01" />
                                    <FluentLabel>Min Azimuth: @((Options.MinAzimuth * 180 / Math.PI).ToString("F0"))°</FluentLabel>
                                    <FluentSlider @bind-Value="Options.MinAzimuth" Min="@(-Math.PI)" Max="@Math.PI" Step="0.01" />
                                }
                                <FluentCheckbox @bind-Value="Options.ConstrainDistance" Label="Constrain Distance" />
                                @if (Options.ConstrainDistance)
                                {
                                    <FluentLabel>Max Distance: @Options.MaxDistance.ToString("F1")</FluentLabel>
                                    <FluentSlider @bind-Value="Options.MaxDistance" Min="1" Max="1000" Step="0.5" />
                                    <FluentLabel>Min Distance: @Options.MinDistance.ToString("F2")</FluentLabel>
                                    <FluentSlider @bind-Value="Options.MinDistance" Min="0.1" Max="10" Step="0.1" />
                                }
                                <FluentLabel>Orbit Sensitivity: @Options.OrbitSensitivity.ToString("F5")</FluentLabel>
                                <FluentSlider @bind-Value="Options.OrbitSensitivity" Min="0.001" Max="0.1" Step="0.001" />
                                <FluentLabel>Zoom Sensitivity: @Options.ZoomSensitivity.ToString("F5")</FluentLabel>
                                <FluentSlider @bind-Value="Options.ZoomSensitivity" Min="0.0001" Max="0.01" Step="0.0001" />
                                <FluentLabel>Pan Sensitivity: @Options.PanSensitivity.ToString("F5")</FluentLabel>
                                <FluentSlider @bind-Value="Options.PanSensitivity" Min="0.0001" Max="0.01" Step="0.001" />
                                <FluentLabel>Pan Speed (Shift): @Options.PanSpeedMultiplier.ToString("F1")</FluentLabel>
                                <FluentSlider @bind-Value="Options.PanSpeedMultiplier" Min="1" Max="10" Step="0.5" />
                            </FluentStack>
                        </FluentAccordionItem>
                    </FluentAccordion>
                    <FluentAccordion>
                        <FluentAccordionItem Heading="🎬 Rendering">
                            <FluentStack Orientation="Orientation.Vertical">
                            </FluentStack>
                        </FluentAccordionItem>
                    </FluentAccordion>
                </FluentStack>
            </div>
        </Body>
    </FluentPopover>
    <FluentPopover AnchorId="help"
                   Style="width:300px;"
                   @bind-Open="_helpPopover"
                   HorizontalPosition="HorizontalPosition.Right">
        <Body>
            <h4>🎮 Camera Controls</h4>
            <div class="control-group">
                <strong>🖱️ Mouse:</strong>
                <ul>
                    <li><strong>Left Drag:</strong> Rotate</li>
                    <li><strong>Right Drag:</strong> Pan</li>
                    <li><strong>Wheel:</strong> Zoom</li>
                    <li><strong>Double-Click:</strong> Pick</li>
                </ul>
            </div>
            <div class="control-group">
                <strong>⌨️ Keyboard:</strong>
                <ul>
                    <li><strong>W/S:</strong> Forward / Back</li>
                    <li><strong>A/D:</strong> Left / Right</li>
                    <li><strong>Q/E:</strong> Down / Up</li>
                    <li><strong>Shift:</strong> Faster</li>
                    <li><strong>.</strong> Toggle Panel</li>
                </ul>
            </div>
        </Body>
    </FluentPopover>

</div>

<style>
    .toolbar-buttons {
        animation: fadeToTransparent 5s ease-in-out forwards;
    }

        .toolbar-buttons:hover:not(.mouse-down),
        .toolbar-buttons.popover-open {
            animation: none;
            opacity: 1 !important;
        }

    @@keyframes fadeToTransparent {
        from {
            opacity: 1;
        }

        to {
            opacity: 0.001;
        }
    }
</style>

@code {
    private bool _cameraPopover = false;
    private bool _optionsPopover = false;
    private bool _helpPopover = false;
    private bool IsAnyPopoverOpen => _cameraPopover || _optionsPopover || _helpPopover;
    private bool _isMouseButtonDown;

    [Parameter]
    public string Width { get; set; } = "100%";

    [Parameter]
    public string Height { get; set; } = "100vh";

    private ElementReference? _canvasRef;
    private BugViewerOptions _options;

    [Parameter]
    public BugViewerOptions Options
    {
        get => _options;
        set
        {
            if (!ReferenceEquals(_options, value))
            {
                _options = value;
                _options.PropertyChanged += OnOptionsChanged;
            }
        }
    }

    public OrbitCamera? Camera { get; private set; }

    private IJSObjectReference? _module;
    private DotNetObjectReference<BugViewer>? _dotNetRef;
    private bool _ready;
    private string? _error;
    private bool _isDragging;
    private bool _isPanning;
    private double _lastPointerX;
    private double _lastPointerY;
    private HashSet<string> _pressedKeys = new();
    private System.Threading.Timer? _keyboardMoveTimer;
    private Sphere totalSphere;
    private Dictionary<AbstractObject3D, Sphere> objectSpheres = new();
    private List<MeshData> _meshes = new();
    private List<LineData> _lines = new();
    private List<MeshData> _billBoards = new();
    private double _canvasWidth = 800;
    private double _canvasHeight = 600;
    private DateTime _lastClickTime = DateTime.MinValue;
    private double _lastClickX;
    private double _lastClickY;
    private const double DoubleClickTimeMs = 300;
    private const double DoubleClickDistancePx = 5;
    public double LatestFrameMs { get; private set; }

    Option<int>? selectedIntOption;
    private List<Option<int>> _sampleCountItems = new()
    {
        new() { Value = 1, Text = "1x (No MSAA)" },
        // new() { Value = 2, Text = "2x" },  //generally not supported
        new() { Value = 4, Text = "4x MSAA" },
        new() { Value = 8, Text = "8x MSAA" }
    };
    private void SampleCountOptionChanged(string args)
    {
        Options.SampleCount = int.Parse(args);
    }
    public event Action<Ray>? OnPickingRayCreated;

    protected override void OnInitialized()
    {
        if (Options is null)
        {
            Options = BugViewerOptions.Default;
        }

        Camera = new OrbitCamera(Vector3.Zero, Options);
        _keyboardMoveTimer = new System.Threading.Timer(_ => ProcessKeyboardMovement(), null, 0, 16);
    }



    private void OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == ",")
        {
            ShowOptionsPanel();
            return;
        }

        if (e.Key == ".")
        {
            ShowCameraPanel();
            return;
        }

        if (e.Key == "?" || (e.Key == "/"))
        {
            ShowHelpPanel();
            return;
        }

        _pressedKeys.Add(e.Key.ToLower());
    }

    private void ShowOptionsPanel()
    {
        _optionsPopover = !_optionsPopover;
        _helpPopover = false;
        _cameraPopover = false;
    }

    private void ShowHelpPanel()
    {
        _optionsPopover = false;
        _helpPopover = !_helpPopover;
        _cameraPopover = false;
    }

    private void ShowCameraPanel()
    {
        _optionsPopover = false;
        _helpPopover = false;
        _cameraPopover = !_cameraPopover;
    }

    private void OnKeyUp(KeyboardEventArgs e)
    {
        _pressedKeys.Remove(e.Key.ToLower());
    }

    private void OnPointerDown(PointerEventArgs e)
    {
        var currentTime = DateTime.Now;
        var timeSinceLast = (currentTime - _lastClickTime).TotalMilliseconds;
        var dist = Math.Sqrt(Math.Pow(e.ClientX - _lastClickX, 2) + Math.Pow(e.ClientY - _lastClickY, 2));

        if (e.Button == 0 && timeSinceLast <= DoubleClickTimeMs && dist <= DoubleClickDistancePx)
        {
            OnDoubleClick(e);
            return;
        }

        if (e.Button == 0)
        {
            _lastClickTime = currentTime;
            _lastClickX = e.ClientX;
            _lastClickY = e.ClientY;
            _isDragging = true;
            _isPanning = false;
            _lastPointerX = e.ClientX;
            _lastPointerY = e.ClientY;
        }
        else if (e.Button == 2)
        {
            _isPanning = true;
            _isDragging = false;
            _lastPointerX = e.ClientX;
            _lastPointerY = e.ClientY;
        }
    }

    private async Task OnDoubleClick(PointerEventArgs e)
    {
        if (_module is null || !_ready)
        {
            return;
        }

        var rect = await _module.InvokeAsync<BoundingClientRect>("getBoundingClientRect", _canvasRef);
        var rx = e.ClientX - rect.Left;
        var ry = e.ClientY - rect.Top;
        var pickingRay = Camera.CreateRayFromScreenPoint(rx, ry, rect.Width, rect.Height);
        await AddTextBillboardAsync("dbl", "Picked", pickingRay.Anchor + 15 * pickingRay.Direction, System.Drawing.Color.Blue, System.Drawing.Color.White);
        OnPickingRayCreated?.Invoke(pickingRay);
    }

    private class BoundingClientRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    private async Task OnPointerMove(PointerEventArgs e)
    {
        if (_isDragging)
        {
            var dx = e.ClientX - _lastPointerX;
            var dy = e.ClientY - _lastPointerY;
            _lastPointerX = e.ClientX;
            _lastPointerY = e.ClientY;
            Camera.Orbit(dx, dy);

            if (_module != null && _ready)
            {
                await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
            }
        }
        else if (_isPanning)
        {
            var dx = e.ClientX - _lastPointerX;
            var dy = e.ClientY - _lastPointerY;
            _lastPointerX = e.ClientX;
            _lastPointerY = e.ClientY;
            Camera.PanWithMouse(dx, dy, e.ShiftKey);

            if (_module != null && _ready)
            {
                await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
            }
        }
    }

    private void OnPointerUp(PointerEventArgs e)
    {
        if (e.Button == 0)
        {
            _isDragging = false;
        }
        else if (e.Button == 2)
        {
            _isPanning = false;
        }
    }

    private async Task OnWheel(WheelEventArgs e)
    {
        Camera.Zoom(e.DeltaY);

        if (_module != null && _ready)
        {
            await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
        }
    }

    private async void ProcessKeyboardMovement()
    {
        if (_pressedKeys.Count == 0 || _module == null || !_ready)
        {
            return;
        }

        double forward = 0, right = 0, up = 0;
        bool shift = _pressedKeys.Contains("shift");

        if (_pressedKeys.Contains("w"))
        {
            forward += 1;
        }

        if (_pressedKeys.Contains("s"))
        {
            forward -= 1;
        }

        if (_pressedKeys.Contains("d"))
        {
            right += 1;
        }

        if (_pressedKeys.Contains("a"))
        {
            right -= 1;
        }

        if (_pressedKeys.Contains("q"))
        {
            up -= 1;
        }

        if (_pressedKeys.Contains("e"))
        {
            up += 1;
        }

        if (forward != 0 || right != 0 || up != 0)
        {
            Camera.PanWithKeyboard(forward, right, up, shift);

            try
            {
                await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
            }
            catch
            {
                // Handle error silently
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        OnPickingRayCreated += OnPickingRayRun;

        try
        {
            _module = await JS.InvokeAsync<IJSObjectReference>("import", $"/_content/BugViewer/js/webgpu-canvas.js?v={DateTime.UtcNow.Ticks}");
        }
        catch (JSException jse)
        {
            _error = $"Failed to import webgpu module: {jse.Message}";
            StateHasChanged();
            return;
        }
        catch (Exception ex)
        {
            _error = $"Unexpected error importing webgpu module: {ex.Message}";
            StateHasChanged();
            return;
        }

        _dotNetRef = DotNetObjectReference.Create(this);

        try
        {
            await SendOptionsToJavaScriptAsync(true);
        }
        catch (Exception ex)
        {
            _error = $"Error initializing WebGPU canvas: {ex.Message}";
            StateHasChanged();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        await SendOptionsToJavaScriptAsync(false);
    }

    private async Task SendOptionsToJavaScriptAsync(bool init)
    {
        if (_module is null)
        {
            return;
        }

        if (init)
        {
            await _module.InvokeVoidAsync("initGPU_Canvas", _dotNetRef, _canvasRef, Options.ToJavascriptOptions(), Camera.ConvertMatrixToJavaScript());
        }
        else
        {
            await _module.InvokeVoidAsync("updateDisplayOptions", Options.ToJavascriptOptions());
            await SendProjectionMatrixToJavaScriptAsync();
        }
    }

    [JSInvokable]
    public Task OnFrameMsUpdate(double ms)
    {
        LatestFrameMs = ms;
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnWebGpuReady()
    {
        _ready = true;
        _error = null;
        await SendProjectionMatrixToJavaScriptAsync();
        StateHasChanged();
    }

    [JSInvokable]
    public Task OnWebGpuError(string message)
    {
        _ready = false;
        _error = message;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnCanvasResized(double w, double h)
    {
        _canvasWidth = w;
        _canvasHeight = h;
        await SendProjectionMatrixToJavaScriptAsync();
    }

    private async Task SendProjectionMatrixToJavaScriptAsync()
    {
        if (_module is null || !_ready || Camera is null)
        {
            return;
        }

        try
        {
            var proj = Camera.ConvertProjectionMatrixToJavaScript(_canvasWidth, _canvasHeight);
            await _module.InvokeVoidAsync("writeProjectionMatrix", proj);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine(ex.Message);
        }
    }

    public async ValueTask DisposeAsync()
    {
        Camera = new OrbitCamera(Camera.Target, Options);
        _keyboardMoveTimer?.Dispose();
        Options.PropertyChanged -= OnOptionsChanged;

        if (_module != null)
        {
            try
            {
                await _module.InvokeVoidAsync("disposeWebGPU_Canvas");
            }
            catch
            {
                // Handle error silently
            }

            try
            {
                await _module.DisposeAsync();
            }
            catch
            {
                // Handle error silently
            }
        }

        _dotNetRef?.Dispose();
    }

    public void ResetCamera()
    {
        Camera.Reset(totalSphere);
        _module?.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
    }

    private async Task HandleCameraReset()
    {
        ResetCamera();
    }

    private async Task HandleCameraCardinalView(CardinalDirection dir)
    {
        if (Camera is null)
        {
            return;
        }

        ResetCamera();
        Camera.SetCardinalView(dir);

        if (_module != null && _ready)
        {
            await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
        }
    }

    private async void OnOptionsChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        if (e?.PropertyName == nameof(Options.ZIsUp))
        {
            Camera.SwapCameraUp();
            await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
        }

        if (e?.PropertyName == nameof(Options.IsProjectionCamera))
        {
            Options.AdjustCameraProjectionParameters();
        }
        StateHasChanged();
        await SendOptionsToJavaScriptAsync(false);
    }


    private void OnPickingRayRun(Ray pickingRay)
    {
        Console.WriteLine($"Picking ray: O({pickingRay.Anchor.X:F2},{pickingRay.Anchor.Y:F2},{pickingRay.Anchor.Z:F2}) D({pickingRay.Direction.X:F2},{pickingRay.Direction.Y:F2},{pickingRay.Direction.Z:F2})");
    }

    private async void UpdateViewer(bool sphereChanged)
    {
        if (Camera is null || _module is null)
        {
            return;
        }

        if ((sphereChanged && Options.AutoResetCamera == UpdateTypes.SphereChange) || Options.AutoResetCamera == UpdateTypes.OnDataChange)
        {
            ResetCamera();

            try
            {
                await _module.InvokeVoidAsync("writeViewMatrix", Camera.ConvertMatrixToJavaScript());
            }
            catch
            {
                // Handle error silently
            }
        }

        if ((sphereChanged && Options.AutoUpdateGrid == UpdateTypes.SphereChange) || Options.AutoUpdateGrid == UpdateTypes.OnDataChange)
        {
            Options.GridSize = Options.AutoGridBuffer * (totalSphere.Center.Length() + totalSphere.GetRadius());
            OnOptionsChanged(null, null);
        }
    }

    private bool UpdateSpheresAdd(AbstractObject3D obj3D)
    {
        var sphere = MinimumSphere.Run(obj3D.Vertices);
        objectSpheres[obj3D] = sphere;
        var need = !Sphere.AContainsB(totalSphere, sphere);

        if (need)
        {
            var newSphere = MinimumSphere.Run(objectSpheres.Keys.SelectMany(o => o.Vertices));
            need = !Sphere.IsPracticallySame(newSphere, totalSphere);

            if (need)
            {
                totalSphere = newSphere;
            }
        }

        return need;
    }

    private bool UpdateSpheresRemove(AbstractObject3D obj3D)
    {
        var sphere = objectSpheres[obj3D];
        objectSpheres.Remove(obj3D);
        var need = obj3D.Vertices.Any(v => !Sphere.OnSurface(totalSphere, v));

        if (need)
        {
            var newSphere = MinimumSphere.Run(objectSpheres.Keys.SelectMany(o => o.Vertices));
            need = !Sphere.IsPracticallySame(newSphere, totalSphere);

            if (need)
            {
                totalSphere = newSphere;
            }
        }

        return need;
    }

    public async Task AddMeshAsync(MeshData mesh)
    {
        _meshes.Add(mesh);
        UpdateViewer(UpdateSpheresAdd(mesh));
        await _module.InvokeVoidAsync("addMesh", mesh.CreateJavascriptData());
    }

    public async Task AddLinesAsync(LineData path)
    {
        _lines.Add(path);
        UpdateViewer(UpdateSpheresAdd(path));
        await _module.InvokeVoidAsync("addLines", path.CreateJavascriptData());
    }

    public async Task RemoveMeshAsync(MeshData mesh)
    {
        var index = _meshes.IndexOf(mesh);

        if (index < 0)
        {
            return;
        }

        UpdateViewer(UpdateSpheresRemove(mesh));
        await _module.InvokeVoidAsync("removeMesh", index);
    }

    public async Task RemoveLinesAsync(LineData path)
    {
        var index = _lines.IndexOf(path);

        if (index < 0)
        {
            return;
        }

        UpdateViewer(UpdateSpheresRemove(path));
        await _module.InvokeVoidAsync("removeLines", index);
    }

    public async Task ClearAllMeshesAsync()
    {
        if (_meshes.Count == 0)
        {
            return;
        }

        var need = _meshes.All(m => UpdateSpheresRemove(m));
        _meshes.Clear();
        UpdateViewer(need);
        await _module.InvokeVoidAsync("clearAllMeshes");
    }

    public async Task ClearAllLinesAsync()
    {
        if (_lines.Count == 0)
        {
            return;
        }

        var need = _lines.All(l => UpdateSpheresRemove(l));
        _lines.Clear();
        UpdateViewer(need);
        await _module.InvokeVoidAsync("clearAllLines");
    }

    public async Task AddTextBillboardAsync(string id, string text, Vector3 position, System.Drawing.Color backgroundColor, System.Drawing.Color textColor)
    {
        if (_module is null || !_ready)
        {
            throw new InvalidOperationException("Not ready");
        }

        var billboardData = new TextBillboard
        {
            BackgroundColor = backgroundColor,
            TextColor = textColor,
            Text = text,
            Vertices = new List<Vector3> { position },
            Id = id
        };

        await _module.InvokeVoidAsync("addTextBillboard", billboardData.CreateJavascriptData());
    }

    public async Task RemoveTextBillboardAsync(string id)
    {
        if (_module is null)
        {
            return;
        }

        await _module.InvokeVoidAsync("removeTextBillboard", id);
    }

    public async Task ClearAllTextBillboardsAsync()
    {
        if (_module is null)
        {
            return;
        }

        await _module.InvokeVoidAsync("clearAllTextBillboards");
    }

    private void ResetToDefaults()
    {
        Options.ResetToDefault();
    }
}